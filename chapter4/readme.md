# Ownership
Rust做出了以下兩個承諾，這兩個承諾對安全的系統程式設計語言都至關重要：

- 您可以决定程式中每個值的使用壽命。 Rust在您的控制下迅速釋放屬於某個值的記憶體和其他資源。
- 即便如此，在對象被釋放後，您的程式將永遠不會使用指向對象的指針。 在C和C++中，使用懸空指針是一個常見的錯誤：如果你運氣好，你的程式就會崩潰。 如果你運氣不好，你的程式有一個安全性漏洞。 Rust在編譯時發現了這些錯誤。

許多語言都使用垃圾收集來實現第二個承諾，只有當指向對象的所有可訪問指針都消失時，才會自動釋放對象。 但作為交換，您可以將對象何時釋放的控制權交給收集器。 總的來說，垃圾收集器是令人驚訝的野獸，理解為什麼記憶體沒有被釋放
你期望的可能是一個挑戰。 如果你使用的對象代表了發送的檔案、網絡連接或其他作業系統資源，那麼不能相信它們會在你想要的時間被釋放，並且它們的底層資源也會隨之被清理，這是令人失望的。


但這些限制的最終效果是給混亂帶來足够的秩序，允許Rust的編譯時檢查來驗證你的程式是否沒有記憶體安全錯誤：懸掛指針、雙重釋放、使用未初始化的記憶體等等。在運行時，你的指針是記憶體中的簡單地址，就像在C和C++中一樣。 不同之處在於，您的程式碼已經被證明可以安全地使用它們。


這些相同的規則也構成了Rust支持安全併發程式的基礎。 使用Rust精心設計的線程原語，確保程式碼正確使用記憶體的規則也可以證明它沒有數據競爭。 Rust程式中的錯誤不會導致一個線程破壞另一個線程的數據，從而在系統的不相關部分引入難以複製的故障。 多執行緒程式碼中固有的不確定性行為與為處理它而設計的功能（互斥、消息通道、原子值等）隔離，而不是出現在普通記憶體引用中。 C和C++中的多執行緒程式碼贏得了醜陋的聲譽，但Rust很好地修復了它。


## Owenship

以c++語言舉例

```c++
std::string s = "frayed knot";
```

1. std::string对象本身始终只占用三个字（word）的空间，包括指向堆分配缓冲区的指针、缓冲区的总容量（即文本在必须分配更大缓冲区来容纳之前可以增长的大小）以及当前持有的文本的长度。这些字段是std::string类的私有字段，无法由字符串的用户直接访问。
2. std::string对象拥有其缓冲区：当程序销毁该字符串时，字符串的析构函数会释放缓冲区。过去，一些C++库在多个std::string值之间共享一个缓冲区，使用引用计数来决定何时释放缓冲区。但是，较新版本的C++规范实际上禁止了这种表示方式；现代的C++库都采用了本文所示的方法。在这种情况下，通常认为，虽然其他代码可以创建指向所拥有内存的临时指针，但是在所有者决定销毁所拥有的对象之前，该代码有责任确保其指针已经消失。你可以创建指向std::string缓冲区中的字符的指针，但是当字符串被销毁时，你的指针将变为无效，你需要确保不再使用它。所有者决定了所拥有对象的生命周期，其他所有代码都必须尊重其决策。

Rust將這一原則從注釋中删除，並在語言中明確表示。 在Rust中，每個值都有一個决定其生存期的所有者。 當所有者被釋放時——在Rust術語中被丟棄——所擁有的值也會被丟棄。 這些規則的目的是讓您只需檢查程式碼就可以輕鬆地找到任何給定值的生存期，從而控制系統語言應該提供的生存期。
變數擁有其值。 當控制項離開聲明變數的塊時，變數會被丟棄，囙此其值也會隨之被丟棄。例如：

```rust

fn print_padovan() {
	let mut padovan = vec![1,1,1]; // allocated here foriin3..10
  {
}
let next = padovan[i-3] + padovan[i-2];
    padovan.push(next);
}
println!("P(1..10) = {:?}", padovan);
// dropped here

```



變量類型`std::vec::Vec<i32>` 是32位向量組合，和c++中的`std::string`類似，

> 說的是堆棧的東西，看暈了



Rust程式通常根本不會顯式地删除值，就像C和C++程式使用free和delete一樣。 在Rust中删除值的方法是以某種管道將其從所有權樹中删除：通過離開變數的範圍，或從向量中删除元素，或諸如此類的管道。在這一點上，Rust確保正確地删除值及其所擁有的一切。





## Moves

在Rust中，對於大多數類型，將值分配給變數、將其傳遞給函數或從函數返回等操作<u>不會複製值：它們會移動值</u>。源將值的所有權交給目標，並變得不熟悉； 目的地現在控制值的生存期。 Rust程式構建和拆除複雜的結構——一次一個值，一次一次移動。





您可能會驚訝於Rust會改變這些基本操作的含義； 當然，在歷史的這一點上，這項任務應該非常明確。 然而，如果你仔細觀察不同的語言是如何選擇處理工作的，你會發現不同的學校實際上有很大的差异。 這種比較也使Rust選擇的意義和後果更容易理解。

#### **以python代碼為例**

```python
s = [ 'udon','ramen','soob']
t = s 
u = s
```

每個Python對象都有一個引用計數，跟踪當前引用它的值的數量。囙此，在賦值給s之後，程式的狀態如圖4-5所示（注意，有些欄位被省略了）。



由於只有s指向該清單，囙此該清單的引用計數為1； 並且由於清單是唯一指向字串的對象，所以它們的每個引用計數也是1。



當程式執行對t和u的賦值時會發生什麼？ Python只需使目標指向與源相同的對象，並新增對象的引用計數即可實現賦值。 囙此，程式的最終狀態如圖4-6所示。

<img src= 'python_assign.png'>



**Python已經將指針從s複製到t和u中，並將清單的引用計數更新為3**。 Python中的賦值很便宜，但因為它創建了對對象的新引用，所以我們必須維護引用計數，以知道何時可以釋放值。

#### 現在考慮類似的C++程式碼

```c++
using namespace std;
vector <string>  s = {"udon","ramen","soba"};
vector <string>  t = s ;
vector <string>  u = s ;


```

當程式將s分配給t和u時會發生什麼？ 分配一個std::vector會在C++中生成該向量的副本； std::string的行為類似。 囙此，當程式到達該程式碼的末尾時，它實際上已經分配了三個向量和九個字串（圖4-8）。

<img src = 'c++_assign.png'>

根據所涉及的值，C++中的賦值可能會消耗無限量的記憶體和處理器時間。 然而，優點是程式很容易决定何時釋放所有記憶體：當變數超出範圍時，這裡分配的所有內容都會自動清理。



從某種意義上說，C++和Python選擇了相反的權衡：Python以需要引用計數（以及在一般情况下的垃圾收集）為代價，使賦值變得便宜。 C++保持所有記憶體的所有權是透明的，代價是讓賦值執行對象的深度複製。 C++程式師通常對這種選擇不太感興趣：深度複製可能很昂貴，而且通常有更實用的替代方案。

#### Rust裡面的處理

```rust
let s = vec!["udon".to_string(),"ream".to_string(),"soba".to_string()];
let t = s;
let u = s;

```

與C和C++一樣，Rust將“udon”等純字串文字放在只讀記憶體中，囙此為了與C++和Python示例進行更清晰的比較，我們在這裡調用to_string來獲取堆分配的字串值。



 初始化使t=s； 將向量的三個頭欄位從s移動到t； 現在t擁有向量。 向量的元素保持不變，字串也沒有發生任何變化。 每個價值觀仍然有一個單一的所有者，儘管其中一個已經易手。 沒有要調整的引用計數。 編譯器現在認為s未初始化。



那麼，當我們到達初始化時會發生什麼呢；？ 這會將未初始化的值s分配給u。Rust謹慎地禁止使用未初始化的數值，囙此編譯器會拒絕此程式碼，並出現以下錯誤：

```
error[E0382]: use of moved value: `s`
     --> ownership_double_move.rs:9:9
| 8 | | 9 | | |
let t = s;
    - value moved here
let u = s;
    ^ value used here after move
```



想想Rust在這裡使用移動的後果。 與Python一樣，賦值也很便宜：程式只需將向量的三個單詞的頭從一個位置移動到另一個位置。 但與C++一樣，所有權總是明確的：程式不需要引用計數或垃圾收集就可以知道何時釋放向量元素和字串內容。
你所付出的代價是，當你想要副本時，你必須明確要求。 如果您希望最終處於與C++程式相同的狀態，並且每個變數都持有結構的獨立副本，則必須調用向量的尅隆方法，該方法將執行向量及其元素的深度複製：

```
let s = vec!["udon".to_string(),"ream".to_string(),"soba".to_string()];
let t = s.clone();
let u = s.clone();
```



### More Operation that move 

在迄今為止的示例中，我們已經展示了初始化，在let語句中變數進入作用域時為其提供值。 為變數賦值略有不同，因為如果將值移動到已初始化的變數中，Rust會删除該變數的先前值。 例如

```rust
let mut s = "Govinda".to_string();
s = "Siddhartha".to_string(); // "Govinda" drop here 

```

在這段程式碼中，當程式將字串“Siddhartha”分配給s時，其先前的值“Govinda”將首先被删除。 但請考慮以下內容：

```rust
let mut s = "Govinda".to_string();
let t=s;
s = "Siddhartha".to_string(); // nothing is dropped here
```

我們在這裡的例子中使用了初始化和賦值，因為它們很簡單，但Rust將移動語義應用於幾乎任何值的使用。 將參數傳遞給函數會將所有權轉移到函數的參數； 從函數返回值會將所有權轉移到調用方。 構建元組會將值移動到元組中。 等等



像這樣轉移價值觀聽起來可能效率低下，但有兩件事需要記住。 首先，移動總是適用於適當的值，而不是它們擁有的堆存儲。 對於向量和字串，適當的值僅為三個單詞的標題； 潜在的大型元素數組和文字緩衝區位於堆中的位置。 其次，Rust編譯器的程式碼生成善於“看透”所有這些動作； 在實踐中，機器程式碼通常將值直接存儲在它所屬的位置。



#### Moves and Control Flow 

前面的例子都有非常簡單的控制流程； 移動如何與更複雜的程式碼~~互動？ 一般原理是，如果一個變數的值可能被移走了，而且從那以後它肯定沒有被賦予新的值，那麼它就被認為是未初始化的。 例如，如果一個變數在計算if運算式的條件後仍然有一個值，那麼我們可以在兩個分支中都使用它：~~

```rust
let x = vec![10,20,30];
if c{
  f(x); // ok to move from x here
}else{
  g(x);	// and ok to also move from x here
}
h(x) 		// x is uninitialized here if either path uses it
```

出於類似的原因，禁止從迴圈中的變數移動：

```
let x = vec![10,20,30];
while f(){
	g(x);
}
```



#### Moves and Indexed Content

我們已經提到，<u>移動會使其源未初始化，因為目的地擁有該值的所有</u>權。 但並不是每一種價值所有者都準備不被初始化。



 但是，如果你真的想把一個元素從向量中移出怎麼辦？ 您需要找到一種方法，該方法可以尊重類型的限制。 以下是三種可能性：

> index.rs

```rust
// build a vector of the strings 
let mut x = Vec::new();
for i in 101..106{
  x.push(i.to_string());
}

// 1. pop a value off the end of the vector
let fifth = v.pop().unwrap();
assert_eq!(fifth,"105");

// 
```



## Copy Types:The exception to Moves

到目前為止，我們展示的移動值的示例涉及向量、字串和其他類型，這些類型可能會佔用大量記憶體，並且複製成本高昂。



移動可以保持此類類型的所有權清晰且分配成本低廉。 但對於更簡單的類型，如整數或字元，這種謹慎的處理實際上是沒有必要的。





## Rc and Arc
儘管在典型的Rust程式碼中，大多數值都有唯一的所有者，但在某些情况下，很難找到每一個具有所需生存期的所有者； 你希望這個值一直存在，直到每個人都使用完它。對於這些情况，**Rust提供了引用計數的指針類型Rc和Arc**。正如你對Rust所期望的那樣，使用這些指針是完全安全的：你不能忘記調整引用計數，或者創建其他指向Rust沒有注意到的引用的指針， 或者偶然發現C++中伴隨引用計數指針類型的任何其他類型的問題。



Rc和Arc類型非常相似； 它們之間唯一的區別是，<u>Arc可以安全地直接在線程之間共亯</u>——名稱Arc是原子引用計數的縮寫——而<u>普通Rc使用更快的非執行緒安全程式碼來更新其引用計數。</u> 如果你不需要在線程之間共亯指針，就沒有理由支付Arc的效能損失，所以你應該使用Rc； Rust可以防止您意外地將一個線程越過線程邊界。 這兩種類型在其他方面是等效的，囙此在本節的其餘部分中，我們將只討論Rc。



> rc.rs



以這種管道在Rust中洩露值是可能的，但這種情況很少發生。 在某個時刻，如果不使舊值指向新值，就無法創建迴圈。 這顯然要求舊值是可變的。 由於Rc指針保持其引用不可變，囙此通常不可能創建迴圈。 然而，Rust確實提供了創建其他不可變值的可變部分的方法； 這被稱為內部可變性，