// 僅從g的簽名來看，Rust就知道它不會在任何可能比調用更長壽的地方保存p：
// 包含調用的任何生存期都必須適用於“a”。囙此，Rust為&x選擇了盡可能小的生存期：對g的調用的生存期。
// 這滿足了所有約束：它的壽命不超過x，並包含了對g的整個調用。囙此，這段程式碼通過了測試。
fn g<'a>(p: &'a i32){...}
let x = 10;
g(&x);
