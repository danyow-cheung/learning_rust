# Why Rust

自从我们开始使用高级语言编写操作系统以来的50年里，系统编程语言已经取得了长足的进步，但有两个问题特别难以解决：
- 很難完成`安全性代碼`
- 很難寫，`多線程代碼`

Rust：一种安全的并发语言，具有C和C++的性能。

与C和C++一样，Rust为开发人员提供了对内存使用的精细控制，并在语言的原始操作和运行机器的原始操作之间保持着密切的关系，帮助开发人员预测代码的成本。

## Type Safety

什麼是`type safety`?
在c語言中，未定義的行為是這樣的
```c
int main(int argc,char ** argv){
    unsigned long a[1];
    a[3] = 0x7ffff7b36cebUL; 
    return 0;
} 
```
根據C99，因為這個程式訪問數組a末端的一個元素，所以它的行為是未定義的，這意味著它可以做任何事情。 當我們在Jim的筆記型電腦上運行這個程式時，它產生了以下輸出：
```powershell
    undef: Error: .netrc file is readable by others.
    undef: Remove password or make file unreadable by others.
```
程序崩潰的原因是因為Jim的電腦沒有`.netrc`文件
C編譯器為該主函數生成的機器程式碼恰好將數組a放在堆棧上的返回地址前三個字處，囙此在[3]中存儲0x7ffff7b36cebUL會更改poor main的返回地址，使其指向C標準庫中的程式碼中間，該庫會查閱.netrc檔案以獲取密碼。 當main返回時，執行不會在main的調用程式中恢復，而是在庫中這些行的機器程式碼中恢復：

根據這個例子，讓我們定義一些術語。 如果一個程式的編寫使得任何可能的執行都不會表現出未定義的行為，那麼我們就說這個程式是定義良好的。 如果一種語言的安全性檢查確保每個程式都定義好了，我們就說這種語言是類型安全的。

Python是類型安全的。 Python願意花費處理器時間以比C更友好的管道檢測和處理超出範圍的數組索引：

Rust特殊形式的類型安全對多執行緒程式設計有著令人驚訝的影響。 眾所周知，併發在C和C++中很難正確使用； 開發人員通常只有在單執行緒程式碼被證明無法實現所需效能時才轉向併發。 但是Rust保證併發程式碼不存在數據爭用，從而在編譯時捕獲對互斥對象或其他同步原語的任何濫用。 在Rust中，您可以使用併發性，而不用擔心您的程式碼除了最有成就的程式師之外，其他人都無法處理。
